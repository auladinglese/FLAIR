
package com.flair.server.utilities.textextraction;

import com.flair.server.utilities.ServerLogger;
import org.apache.tika.Tika;
import org.apache.tika.io.TikaInputStream;
import org.apache.tika.metadata.Metadata;
import org.apache.tika.mime.MediaType;
import org.apache.tika.parser.AutoDetectParser;
import org.apache.tika.parser.ParseContext;
import org.apache.tika.sax.BodyContentHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;

import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;

/**
 * Apache Tika implementation of a text extractor
 */
class TikaTextExtractor extends AbstractTextExtractor {
	public TikaTextExtractor() {
		super(TextExtractorFactory.Type.TIKA);
	}

	@Override
	public Output extractText(Input input) {
		boolean error = false;
		String pageText = "";
		MediaType streamType = MediaType.EMPTY;
		boolean isHtml = false;

		try {
			InputStream read = null;
			switch (input.sourceType) {
			case URL:
				read = openURLStream(input.url);
				break;
			case STREAM:
				read = input.stream;
				break;
			}

			TikaInputStream stream = TikaInputStream.get(read);
			Tika pipeline = new Tika();
			Metadata metadata = new Metadata();

			pipeline.setMaxStringLength(-1);
			streamType = pipeline.getDetector().detect(stream, metadata);

			ContentHandler handler = new BodyContentHandler(-1) {
				@Override
				public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
					// Not writing extra new lines generated by XHTMLContentHandler.
				}
			};

			new AutoDetectParser().parse(stream, handler, metadata, new ParseContext());
			pageText = handler.toString();

			// if the source is HTML, run it through boilerpipe to get the relevant text (only for URLs)
			// some HTML pages are detected as plain text by Tika, so allow plain text to count as HTML
			isHtml = streamType == MediaType.TEXT_HTML || streamType == MediaType.TEXT_PLAIN;
			if (isHtml && input.sourceType == Input.SourceType.URL) {
				// the boilerpipe pass can potentially fail/return an empty string
				// if it does, fallback to the original extract
				String extract = AbstractTextExtractor.doBoilerpipePass(pageText);
				if (extract.isEmpty() == false)
					pageText = extract;
			}

			stream.close();
		} catch (Throwable ex) {
			ServerLogger.get().error(ex, "Couldn't extract text. Exception: " + ex.toString());
			error = true;
		}

		return new Output(input, error == false, pageText, isHtml);
	}

	public static boolean isContentHTMLPlainText(String url) throws IOException, URISyntaxException {
		Tika pipeline = new Tika();
		MediaType type;
		try (TikaInputStream in = TikaInputStream.get(openURLStream(url))) {
			type = pipeline.getDetector().detect(in, new Metadata());
		}

		if (type == MediaType.TEXT_HTML || type == MediaType.TEXT_PLAIN || type == MediaType.APPLICATION_XML)
			return true;
		else {
			ServerLogger.get().trace("URL '" + url + "' media type: " + type);
			return false;
		}
	}
}
